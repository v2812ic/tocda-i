% Definición de condiciones
Mach = 0.78;
Alt = 11000;      % metros
ThrustReq = 6000; % empuje requerido [N]

% Cambio de los parámetros del motor 
% Fmax=> Maximum sea-level static thrust (N)
% SFC=> Sea-level static TSFC (kg/(N.s))
% tau=> Fastest engine time constant (s) controla lo rápido que se adapta a
% cambios de throttle. PONERLO BAJO PARA QUE CONVERJA
% Nt=> Ratio of installed to unstalled thrust DEJARLO COMO ESTÁ
% ic_source=> initial thrust source ('Internal' o 'External')
% IC=> initial thrust (N) (solo aplica si ic_source = 'Eternal')

params = struct('Fmax',1.30e5,'SFC',1.10e-4,'tau',0.0000001,'Nt',0.9, ...
                'ic_source','External','IC',6000);

apply_engine_params(params);

% Configuración de la simulación

opts.Model     = 'Turbofan_Model';  %Nombre del modelo de Simulink
opts.StopTime  = '0.0005';   %Tiempo de simulación
opts.ThrustSig = 'Thrust_N';    %Nombre de la señal de empuje
opts.FuelSig   = 'FuelFlow_kgps';   %Nombre de la señal de consumo
opts.UseRapid  = false;     % Modo rápido
opts.TolN      = 1.0;   %Tolerancia en Newtons

% Llamada a la función
[fuelFlow, throttle, thrustAchieved] = FuelFlow_Turbofan(Mach, Alt, ThrustReq, opts);

fprintf('Throttle = %.3f\nThrust = %.1f N\nFuel flow = %.4f kg/s\n', ...
    throttle, thrustAchieved, fuelFlow);

function [fuelFlow, throttle, thrustAchieved] = FuelFlow_Turbofan(Mach, Alt, ThrustReq, opts)
% FuelFlow_Turbofan  Calcula el consumo (kg/s) que cumple un empuje requerido (N)
% usando un modelo de Simulink con el bloque Turbofan Engine System.
%
% USO:
%   [ff, thr, T] = FuelFlow_Turbofan(0.78, 11000, 25000);
%
% ENTRADAS:
%   Mach        - número de Mach (adim)
%   Alt         - altitud [m]
%   ThrustReq   - empuje requerido [N]
%   opts        - (opcional) struct con ajustes:
%                 .Model     (char) nombre del modelo, por defecto 'Turbofan_Model'
%                 .StopTime  (char) tiempo de simulación, por defecto '0.1'
%                 .ThrustSig (char) nombre señal thrust en logsout, por defecto 'Thrust_N'
%                 .FuelSig   (char) nombre señal fuel en logsout, por defecto 'FuelFlow_kgps'
%                 .UseRapid  (logical) usar Rapid Accelerator si está disponible (false)
%                 .TolN      (double) tolerancia de empuje [N] para convergencia (1.0)
%
% SALIDAS:
%   fuelFlow        - consumo de combustible [kg/s]
%   throttle        - mando de acelerador (0..1) que logra ThrustReq
%   thrustAchieved  - empuje alcanzado [N] con ese throttle
%
% REQUISITOS EN EL MODELO:
%   - Variables/puertos de entrada: Throttle, Mach, Alt
%   - Señales registradas en logsout (o Outport con esos nombres):
%       Thrust_N, FuelFlow_kgps


% ---------- CONFIG por defecto ----------
% Comprueba que se la han pasado todo los inputs y sino mete unos por
% defecto. SE podría suprimir esta parte (quizás sería bueno)
if nargin < 4, opts = struct; end
opts = defaults(opts, 'Model', 'Turbofan_Model', ...
                      'StopTime', '0.1', ...
                      'ThrustSig', 'Thrust_N', ...
                      'FuelSig',   'FuelFlow_kgps', ...
                      'UseRapid',  false, ...
                      'TolN',      1.0);

% Comprobación previa
assert(exist([opts.Model '.slx'],'file')==4, ...
    'No se encuentra el modelo %s.slx en el path actual.', opts.Model);

% Prepara simulación (opcional: Rapid Accelerator para acelerar barridos)
simMode = 'normal';
if isfield(opts,'UseRapid') && opts.UseRapid
    simMode = 'rapid';         % 'rapid' = Rapid Accelerator en setModelParameter
end

% Función objetivo: diferencia de empuje para un throttle dado
f_err = @(u) thrust_error(u, Mach, Alt, ThrustReq, opts, simMode);

% 1) Búsqueda gruesa para garantizar cambio de signo (o mínimo)
grid = linspace(0,1,9);
errg = arrayfun(f_err, grid);
[emin, imin] = min(abs(errg));

% 2) Intento con fzero si hay cambio de signo
throttle = NaN;
if any(sign(errg(1:end-1)).*sign(errg(2:end)) < 0)
    % Encuentra intervalo con cambio de signo
    idx = find(sign(errg(1:end-1)).*sign(errg(2:end)) < 0, 1, 'first');
    a = grid(idx); b = grid(idx+1);
    opts_fzero = optimset('Display','off');
    try
        throttle = fzero(f_err, [a b], opts_fzero);
    catch
        throttle = grid(imin); % cae al mejor de la malla
    end
else
    % Minimiza |error| en [0,1]
    opts_fmin = optimset('Display','off');
    throttle = fminbnd(@(u) abs(f_err(u)), 0, 1, opts_fmin);
end

% Saturación y evaluación final
throttle = max(0,min(1,throttle));
[thrustAchieved, fuelFlow] = simulate_once(throttle, Mach, Alt, opts, simMode);

% Aviso si no coincide dentro de tolerancia
if abs(thrustAchieved - ThrustReq) > max(1, opts.TolN)
    warning('Empuje alcanzado %.1f N difiere del requerido %.1f N (|Δ|=%.1f).', ...
        thrustAchieved, ThrustReq, abs(thrustAchieved-ThrustReq));
end
end

% ======= funciones auxiliares =======

function val = thrust_error(u, Mach, Alt, Treq, opts, simMode)
[T, ~] = simulate_once(u, Mach, Alt, opts, simMode);
val = T - Treq;
end

function [ThrustN, Fuel] = simulate_once(ThrottleVal, MachVal, AltVal, opts, simMode)
    % Prepara la entrada de simulación
    in = Simulink.SimulationInput(opts.Model);

    % --- From Workspace requiere timeseries ---
    %  Usamos el mismo StopTime de la simulación para que sea constante en el tiempo
    tEnd = str2double(opts.StopTime);
    if isnan(tEnd), tEnd = 0.1; end
    t = [0 tEnd];

    Throttle_ts = timeseries([ThrottleVal ThrottleVal], t);
    Mach_ts     = timeseries([MachVal MachVal], t);
    Alt_ts      = timeseries([AltVal AltVal], t);

    % Variables disponibles para el modelo
    in = in.setVariable('Throttle', Throttle_ts);
    in = in.setVariable('Mach',     Mach_ts);
    in = in.setVariable('Alt',      Alt_ts);

    % --- Parámetros del modelo: aquí se fija el modo correcto ---
    in = in.setModelParameter('StopTime', opts.StopTime);
    if exist('simMode','var') && ~isempty(simMode)
        in = in.setModelParameter('SimulationMode', simMode);  % 'normal' o 'rapid'
    end

    % Ejecuta la simulación
    out = sim(in);

    % --- Lectura robusta de salidas ---
    ThrustN = NaN; Fuel = NaN;

    % 1) Si usas logsout (Signal Logging)
    if isprop(out,'logsout') && ~isempty(out.logsout)
        try
            ThrustN = out.logsout.getElement(opts.ThrustSig).Values.Data(end);
            Fuel    = out.logsout.getElement(opts.FuelSig).Values.Data(end);
            return
        catch
            % sigue probando con To Workspace
        end
    end

    % 2) Si usas To Workspace con formato Timeseries y ReturnWorkspaceOutputs=on
    if isprop(out, opts.ThrustSig)
        tsT = out.(opts.ThrustSig);
        if isa(tsT, 'timeseries') && ~isempty(tsT.Data)
            ThrustN = tsT.Data(end);
        end
    end
    if isprop(out, opts.FuelSig)
        tsF = out.(opts.FuelSig);
        if isa(tsF, 'timeseries') && ~isempty(tsF.Data)
            Fuel = tsF.Data(end);
        end
    end

    % 3) Fallback: variables en base workspace (no recomendado, pero por si acaso)
    if isnan(ThrustN) || isnan(Fuel)
        try
            Tvar = evalin('base', opts.ThrustSig);
            Fvar = evalin('base', opts.FuelSig);
            ThrustN = last_sample(Tvar);
            Fuel    = last_sample(Fvar);
        catch
            error('No se pudieron leer las salidas "%s" y "%s". Revisa nombres y formato (Timeseries o logsout).', ...
                  opts.ThrustSig, opts.FuelSig);
        end
    end
end

function v = last_sample(x)
    if isa(x,'timeseries')
        v = x.Data(end);
    elseif isstruct(x) && isfield(x,'signals') && isfield(x.signals,'values')
        v = x.signals.values(end);           % Structure With Time
    elseif isnumeric(x)
        v = x(end);
    else
        error('Formato de salida no reconocido.');
    end
end


function v = get_last(logs, name)
el = logs.getElement(name);
if isprop(el,'Values') && ~isempty(el.Values)
    v = el.Values.Data(end);
else
    error('La señal "%s" no tiene datos en logsout.', name);
end
end

function s = defaults(s, varargin)
for k = 1:2:numel(varargin)
    key = varargin{k}; def = varargin{k+1};
    if ~isfield(s, key) || isempty(s.(key)), s.(key) = def; end
end
end


function apply_engine_params(p)
    model = 'Turbofan_Model';

    % 1) Cargar el modelo si no está cargado
    if ~bdIsLoaded(model)
        load_system(model);   % no abre ventana
    end

    % 2) Intentar encontrar el bloque por distintas claves
    blk = '';  % ruta completa al bloque dentro del modelo

    % (a) Por referencia a la librería donde vive el bloque
    hits = find_system(model, 'LookUnderMasks','all', 'FollowLinks','on', ...
        'ReferenceBlock','aerolibpropulsion2/Turbofan Engine System');
    if ~isempty(hits); blk = hits{1}; end

    % (b) Si no, por MaskType típico
    if isempty(blk)
        hits = find_system(model, 'LookUnderMasks','all', 'FollowLinks','on', ...
            'MaskType','Turbofan Engine System');
        if ~isempty(hits); blk = hits{1}; end
    end

    % (c) Si no, por nombre aproximado del bloque dentro del modelo
    if isempty(blk)
        hits = find_system(model, 'LookUnderMasks','all', 'FollowLinks','on', ...
            'Name','Turbofan Engine System');
        if ~isempty(hits); blk = hits{1}; end
    end

    % (d) Último intento: ¿lo llamaste "Turbofan Engine"?
    if isempty(blk)
        hits = find_system(model, 'LookUnderMasks','all', 'FollowLinks','on', ...
            'Name','Turbofan Engine');
        if ~isempty(hits); blk = hits{1}; end
    end

    % Si sigue vacío, avisar con info útil
    if isempty(blk)
        error(['No encuentro el bloque Turbofan dentro de ', model, ...
               '. Abre el modelo y dime el nombre exacto del bloque o selecciona el bloque y usa: ', ...
               'getfullname(gcb)']);
    end

    % 3) Aplicar parámetros (usa num2str para todos menos enums)
    f = @(name,val) set_param(blk, name, num2str(val));

    % ic_source solo acepta 'Internal' o 'External' en tu versión
    if isfield(p,'ic_source')
        set_param(blk,'ic_source', p.ic_source);   % 'Internal' / 'External'
    end
    if isfield(p,'IC');   f('IC',   p.IC);   end     % N
    if isfield(p,'Fmax'); f('Fmax', p.Fmax); end     % N
    if isfield(p,'SFC');  f('SFC',  p.SFC);  end     % kg/(N*s) en MKS
    if isfield(p,'tau');  f('tau',  p.tau);  end     % s
    if isfield(p,'Nt');   f('Nt',   p.Nt);   end     % ratio
    if isfield(p,'units')
        set_param(blk,'units', p.units);            % 'Metric (MKS)' / 'English'
    end

    save_system(model);
end

