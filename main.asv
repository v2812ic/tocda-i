% Inputs: Ninguno 
% Outputs:
%   - Resultados de variables de optimización
%   - Figuras del frente de Pareto
%   - Resumen del proceso
%   - Todo se guarda en Resultados/

clc;
clear;

%% 0. Control y setup de simulación

aviones = ["A320", "B737", "B757"]; % etc
heuristico = true; % genetico
gradiente = true; 

%% 1. Carga de datos del problema

% Construye el controlador de opciones de la simulación
control = struct();
control.aviones = aviones;
control.heuristico = heuristico;
control.gradiente = gradiente;

% Carga las restricciones generales (distancias de aeropuertos) y las
% fronteras de las restricciones (máximos y mínimos)
restriccionesGenerales = load("Data/restriccionesGenerales.mat");
parametrosFijos = restriccionesGenerales.parametros;
fronterasFijas = restriccionesGenerales.fronteras;

for i = 1:length(aviones)

    avionActual = aviones(i);
    
    % Inicialización del objeto del avión
    Avion = Avion(avionActual);

    nvars = 12; % Número total de variables de decisión (que habrá que cambiar para simplificar el problema)
    
    % --- Creación de Funciones ---
    masterEval = @(X) cachedEvaluarVuelo(X, fixedParams, Avion);
    objFcn = @(X) wrapper_getObjetivos(X, masterEval);
    conFcn = @(X) wrapper_getRestricciones(X, masterEval);
    
    options_ga = optimoptions('gamultiobj', ...
        'Display', 'iter', ...
        'PlotFcn', @gaplotpareto, ...
        'PopulationSize', 60, ...
        'UseParallel', true);
    
    [X_ga, F_ga, exitflag_ga, output_ga] = gamultiobj(objFcn, nvars, ...
        [], [], [], [], lb, ub, conFcn, options_ga);
    
    Resultados.(avionActual).ga.X = X_ga;
    Resultados.(avionActual).ga.F = F_ga;
    Resultados.(avionActual).ga.output = output_ga;
    disp('Optimización GA completada.');
    
        
    disp('Ejecutando Algoritmo de Gradiente (fmincon)...');
    
    w1 = 0.5; % 50% importancia al tiempo
    w2 = 0.5; % 50% importancia al consumo
    fminconObj = @(X) wrapper_weightedSum(X, masterEval, w1, w2);
    
    options_fmc = optimoptions('fmincon', ...
        'Algorithm', 'sqp', ...
        'Display', 'iter', ...
        'UseParallel', true);
    
    x0 = (lb + ub) / 2; % Punto de inicio
    
    [X_fmc, F_fmc, exitflag_fmc, output_fmc] = fmincon(fminconObj, x0, ...
        [], [], [], [], lb, ub, conFcn, options_fmc);
    
    Resultados.(avionActual).fmc.X = X_fmc;
    Resultados.(avionActual).fmc.F_scalar = F_fmc;
    Resultados.(avionActual).fmc.output = output_fmc;
    disp('Optimización fmincon completada.');
end
    

%% 5. GUARDADO DE RESULTADOS
save(['Resultados/Resultados_' datetime("now",'yyyymmdd_HHMM') '.mat'], 'Resultados');


%% --- FUNCIONES WRAPPER Y CACHÉ (AL FINAL DEL SCRIPT) ---

function [objetivos, c, ceq, X_cached] = cachedEvaluarVuelo(X, fixedParams, avionObj)
    persistent lastX results
    
    if ~isequal(X, lastX)
        [obj, c_sim, ceq_sim] = evaluarVuelo(X, fixedParams, avionObj);
        
        results.objetivos = obj;
        results.c = c_sim;
        results.ceq = ceq_sim;
        lastX = X;
    end
    
    objetivos = results.objetivos;
    c = results.c;
    ceq = results.ceq;
    X_cached = lastX;
end

function [objetivos] = wrapper_getObjetivos(X, masterEvalHandle)
    [objetivos, ~, ~] = masterEvalHandle(X);
end

function [c, ceq] = wrapper_getRestricciones(X, masterEvalHandle)
    [~, c, ceq] = masterEvalHandle(X);
end

function [obj_scalar] = wrapper_weightedSum(X, masterEvalHandle, w1, w2)
    [objetivos, ~, ~] = masterEvalHandle(X);
    obj_scalar = w1 * objetivos(1) + w2 * objetivos(2);
end